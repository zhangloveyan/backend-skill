---
name: proj-optimize
description: 持续优化与自我进化。收集开发过程中的问题和优化点，批量处理积累的优化需求，验证优化效果。
---

# 持续优化与自我进化

## 适用场景

- 开发过程中发现规范缺失或流程问题
- 项目结束后批量优化积累的问题
- 定期检查和改进开发规范体系

---

## 任务文档同步

- 如存在全流程任务文档，将优化相关文件记录到“扩展产物”
- 上下文快照记录优化状态（不写细节）
- 更新下一步指令

---

## 使用方式

```
/proj-optimize record    # 记录问题和优化点
/proj-optimize          # 执行批量优化（默认模式）
/proj-optimize check    # 检查是否有待优化项
/proj-optimize clean    # 清理已完成的优化记录
```

---

## 1. 记录模式 (`/proj-optimize record`)

### 存储位置
问题记录保存在项目本地文件中：
- **待优化问题**：`docs/optimization/pending-issues.md`
- **优化历史**：`docs/optimization/optimization-log.md`

**优势**：
- 项目级隔离：不同项目的优化问题分开管理
- 持久保存：本地文件，不会丢失
- 版本控制：可纳入 Git 管理，团队共享
- 避免臃肿：每个项目只关注自己的优化点

### 使用时机
- 开发中遇到规范缺失
- 发现流程执行问题
- Skill 使用不便
- 重复性问题出现

### 记录内容
每次记录包含以下信息：
- **问题描述**：具体遇到什么问题
- **影响范围**：对开发的影响
- **优化建议**：初步的解决思路
- **优先级**：P0(阻塞) / P1(重要) / P2(优化)
- **涉及文件**：相关的 Skill 或文档文件

### 记录方式
1. 打开 `docs/optimization/pending-issues.md`
2. 根据优先级添加到对应分类下
3. 使用模板格式记录问题详情
4. 保存文件
5. 同步任务文档（扩展产物与上下文快照）

### 记录模板
参考 [问题记录模板](templates/issue-template.md)

---

## 2. 执行模式 (`/proj-optimize`)

### 执行流程
1. **读取问题列表**：从 `docs/optimization/pending-issues.md` 读取待优化问题
2. **优先级排序**：P0 → P1 → P2 顺序处理
3. **生成优化方案**：分析每个问题，生成详细的修改方案
4. **用户确认**：逐项展示优化方案，等待用户确认
5. **执行修改**：只执行用户确认的优化项
6. **验证改进**：确认优化是否解决问题
7. **更新记录**：将完成的问题移动到 `docs/optimization/optimization-log.md`
8. **同步文档**：必要时更新 CLAUDE.md 索引
9. **同步任务文档**：更新扩展产物与下一步指令

### 用户确认机制
每个优化方案都会详细展示：
- **修改文件**：具体要修改哪些文件
- **修改内容**：详细的修改说明
- **影响范围**：对现有功能的影响
- **风险评估**：修改的风险等级

**确认选项**：
- `y` - 执行此优化
- `n` - 跳过此优化
- `s` - 跳过所有剩余优化
- `a` - 执行所有剩余优化（批量确认）

### 优化方案预览格式
```markdown
## 优化方案预览

### 问题 1/3: [P1] 代码生成缺少异常处理模板

**修改文件**：
- `.claude/skills/proj-gen/templates/service.md`

**修改内容**：
- 在 Service 模板的方法中增加 try-catch 异常处理
- 添加 BusinessException 转换逻辑

**影响范围**：
- 后续使用 /proj-gen 生成的 Service 代码将包含异常处理
- 不影响已有代码

**风险评估**：低风险，向后兼容

**是否执行此优化？**
[y] 是  [n] 否  [s] 跳过所有  [a] 全部执行
```

### 优化原则
- **基于实践**：所有优化都来自真实开发经验
- **用户主导**：所有修改都需要用户明确确认
- **小步快跑**：每次优化1-3个问题，避免大幅变动
- **向后兼容**：尽量保持现有使用方式不变
- **验证效果**：优化后在下次开发中验证是否有效

### 安全保障
- **预览优先**：先展示修改方案，不立即执行
- **逐项确认**：每个修改都需要用户明确同意
- **批量选项**：提供批量确认，提高效率
- **记录选择**：记录用户的确认/拒绝选择，便于后续参考

### 智能跳过
- 如果 `docs/optimization/pending-issues.md` 中没有待处理问题
- 自动提示"当前无待优化项，跳过执行"
- 避免无意义的重复操作

---

## 3. 检查模式 (`/proj-optimize check`)

### 功能
- 读取 `docs/optimization/pending-issues.md` 文件
- 统计各优先级问题数量
- 给出优化建议

### 输出示例
```
优化状态检查：
- 待优化问题：5个
  - P0 (阻塞)：1个
  - P1 (重要)：2个
  - P2 (优化)：2个
- 建议：存在P0问题，建议立即执行优化
```

### 检查文件
- `docs/optimization/pending-issues.md` - 待优化问题
- `docs/optimization/optimization-log.md` - 历史记录（可选）

---

## 4. 清理模式 (`/proj-optimize clean`)

### 功能
- 清理 `docs/optimization/pending-issues.md` 中已标记为完成的问题
- 整理 `docs/optimization/optimization-log.md` 历史记录
- 保持文件整洁，便于查看

### 清理规则
- 移除状态为"已完成"的问题记录
- 保留模板和说明部分
- 整理历史记录的格式

---

## 优化触发点

| 触发场景 | 记录方式 | 优先级 |
|---------|---------|--------|
| 开发阻塞 | 立即记录，标记P0 | 立即优化 |
| 流程不顺 | 开发结束后记录，标记P1 | 项目结束后优化 |
| 使用不便 | 积累记录，标记P2 | 定期批量优化 |
| 重复问题 | 第二次出现时记录，标记P1 | 优先处理 |

---

## 自我进化机制

### 进化路径
```
开发实践 → 发现问题 → /proj-optimize record → 积累问题 → /proj-optimize → 验证效果 → 固化经验
```

### 持续改进循环
1. **实践中发现**：每次开发都可能发现新问题
2. **及时记录**：使用 record 模式立即记录
3. **批量优化**：积累一定数量后统一处理
4. **验证效果**：下次开发中验证改进是否有效
5. **持续迭代**：无效的优化继续改进，有效的固化为规范

### 质量保证
- **问题追踪**：每个问题都有完整的生命周期记录
- **效果验证**：优化后必须在实际开发中验证
- **回滚机制**：无效优化可以回滚到之前版本
- **知识积累**：成功的优化经验固化为最佳实践

---

## 最佳实践

### 记录问题时
- 描述要具体，避免模糊表达
- 提供初步解决思路，便于后续优化
- 标记准确的优先级，合理安排优化顺序

### 执行优化时
- 一次处理1-3个问题，避免过度变动
- 优化后立即在小范围验证效果
- 保留优化前的版本，便于必要时回滚

### 验证效果时
- 在真实开发场景中测试改进效果
- 收集使用反馈，持续调整优化方案
- 将验证结果记录，为后续优化提供参考

通过这套机制，整个开发规范体系能够基于实践不断自我完善，最终实现真正的自我进化。

---

## 模板文件

| 模板 | 文件 | 说明 |
|------|------|------|
| 问题记录模板 | [templates/issue-template.md](templates/issue-template.md) | 记录问题的标准格式和示例 |
| 优化记录模板 | [templates/optimization-log-template.md](templates/optimization-log-template.md) | 记录优化历史的标准格式 |

---

## 项目文件结构

```
docs/
└── optimization/
    ├── pending-issues.md           # 待优化问题列表
    └── optimization-log.md         # 优化历史记录
```

**优势**：
- **项目隔离**：每个项目独立管理优化问题
- **持久保存**：本地文件，不会丢失
- **版本控制**：可纳入 Git，团队共享
- **避免臃肿**：不同项目的问题分开，保持精简
